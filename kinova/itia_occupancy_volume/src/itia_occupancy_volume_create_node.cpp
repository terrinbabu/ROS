#include <ros/ros.h>

#include <thread>
#include <cstdlib>
#include <limits>
#include <fstream>
#include <istream>
#include <algorithm>
#include <std_msgs/Int16.h>
#include <itia_rutils/itia_rutils.h>
#include <itia_occupancy_volume/pcl_utils.h>
#include <itia_occupancy_volume/utils.h>
#include <itia_occupancy_volume/input_utils.h>
#include <itia_occupancy_volume/occupancy_grid.h>

#define REQUIRE( X, Y )\
if( !X )\
{\
  ROS_ERROR("Key '%s' does not exist in the rosparam server. Exit.", std::string(Y).c_str() );\
  throw std::runtime_error(std::string( "Key '"+std::string(Y)+"' does not exist in the rosparam server. Exit.").c_str());\
}

using namespace itia_occupancy_volume;

namespace parser
{
const size_t ERROR_IN_COMMAND_LINE = 1;
const size_t SUCCESS = 0;
const size_t ERROR_UNHANDLED_EXCEPTION = 2;
const size_t JUST_HELP = 3;
} // namespace


size_t parse ( int argc, char **argv, std::string* source, std::string* sourceid, std::string* outputfiledir, int* verbosity )
{
  try
  {
    std::string appName = boost::filesystem::basename ( argv[0] );

    boost::program_options::options_description desc ( "Options" );
    desc.add_options()
    ( "help", "Print help messages" )
    ( "source,s", boost::program_options::value<std::string>()->required(),
      "INPUT SOURCE: < openni_tracker | k2_client | file > \n\
\topenni_tracker: the source is the tf streaming generated from the openni_tracker module (Kinect - Old)\n\
\tk2_client: the source is the tf streaming generated from the k2_client node (Kinect One)\n\
\tfile: Kinect Input File (file generated by Scano SW)" )
    ( "sourceid,i", boost::program_options::value<std::string>()->required(), "source id" )
    ( "odir,o", boost::program_options::value<std::string>()->required(), "Output Directory where save the stl files" )
    ( "verbose,v", boost::program_options::value<std::string>()->required(), "Verbosity level" );

    boost::program_options::variables_map vm;
    try
    {
      boost::program_options::store ( boost::program_options::parse_command_line ( argc, argv, desc ), vm );
      if ( vm.count ( "help" ) )
      {
        std::cout << desc << std::endl;
        return parser::JUST_HELP;
      }
      boost::program_options::notify ( vm );

      *source       = vm["source"].as<std::string>();
      *sourceid     = vm["sourceid"].as<std::string>();
      if ( *source == "file" )
      {
        std::string _filename  = vm["sourceid"].as<std::string>();
        if ( !boost::filesystem::exists ( _filename ) || !boost::filesystem::is_regular ( _filename ) )
          throw boost::program_options::error ( "source file does not exist or is not regular" );
      }
      else if ( *source != "openni_tracker" && *source != "k2_client" )
      {
        std::cout << "SOURCE bad defined" << desc << std::endl;
        return parser::ERROR_IN_COMMAND_LINE;
      }

      *outputfiledir= vm["odir"].as<std::string>();
      if ( !boost::filesystem::exists ( *outputfiledir ) || !boost::filesystem::is_directory ( *outputfiledir ) )
        throw boost::program_options::error ( "Output directory does not exist or is not regular" );
      
      if( vm.count("verbose") )
      {
        std::string v = vm["verbose"].as<std::string>();
        std::cout << "VERBOSE:..." << v <<"..."<< std::endl;
        *verbosity = std::atoi( v.c_str() );
      }
      else
        *verbosity = 0;

    }
    catch ( boost::program_options::error& e )
    {
      std::cerr << "ERROR: " << e.what() << std::endl << std::endl << desc << std::endl;
      return parser::ERROR_IN_COMMAND_LINE;
    }
  }
  catch ( std::exception& e )
  {
    std::cerr << "Unhandled Exception reached the top of main: " << e.what() << ", application will now exit" << std::endl;
    return parser::ERROR_UNHANDLED_EXCEPTION;
  }
  return parser::SUCCESS;
}



bool stop;
void stop_cb(const std_msgs::Int16::ConstPtr& msg){  
  ROS_WARN("Stop Message Received!");
  if(msg->data ==1)
    stop=false;
}
int main(int argc, char **argv)
{
  std::string outfiledir, source, sourceid, kinect_id;
  
  int verbosity;
  if ( parse ( argc , argv, &source, &sourceid, &outfiledir, &verbosity ) != parser::SUCCESS )
    return -1;

  ros::init (argc, argv, "checkTraj");
  ros::NodeHandle node_handle("~");

  ros::Subscriber stop_sub = node_handle.subscribe("/stop",1,stop_cb);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ROS_INFO("Get Data From Param Server");
  std::vector<  std::string >  labels;
  REQUIRE( node_handle.getParam("/labels", labels), "/labels");

//   std::string ns; 
//   REQUIRE( node_handle.getParam("/"+source+"/ns", ns), "/"+source+"/ns") ;
  
  std::vector<  std::string >  labels_used;
  for( auto it = labels.begin(); it != labels.end(); it++) 
  {
    std::string v;  
    if(*it != "time" && source=="k2_client"){ 
      REQUIRE( node_handle.getParam("/"+source+"/labels_map/"+*it, v), "/"+source+"/labels_map/"+*it );
      labels_used.push_back( v );
    }
  }
  
  std::vector< std::vector< std::string > > circles;
  REQUIRE( itia::rutils::getParamMatrix(node_handle, "/circles", circles ), "/circles" );
  for(auto it = circles.begin(); it != circles.end(); it++)
  {
    std::cout << "Circle "<< std::distance(circles.begin(),it) <<"# "; 
    for(auto jt = it->begin(); jt != it->end(); jt++)
       std::cout << *jt << ", ";
    std::cout << std::endl;
  }
    

  std::vector< std::vector< std::string > > segments;
  REQUIRE( itia::rutils::getParamMatrix(node_handle, "/segments", segments ), "/segments" );
  for(auto it = segments.begin(); it != segments.end(); it++)
  {
    std::cout << "Segment "<< std::distance(segments.begin(),it) <<"# "; 
    for(auto jt = it->begin(); jt != it->end(); jt++)
       std::cout << *jt << ", ";
    std::cout << std::endl;
  }
    
  
  std::vector< std::vector< std::string > > trapezoids;
  REQUIRE( itia::rutils::getParamMatrix(node_handle,"/trapezoids", trapezoids ), "trapezoids" );
  for(auto it = segments.begin(); it != segments.end(); it++)
  {
    std::cout << "Trapezoid "<< std::distance(segments.begin(),it) <<"# "; 
    for(auto jt = it->begin(); jt != it->end(); jt++)
       std::cout << *jt << ", ";
    std::cout << std::endl;
  }
    
  node_handle.getParam("/kinect_id",kinect_id);
  std::vector< std::vector< double > > R_kp;
  std::cout << "---------------------------------------------------------------------------------"<<kinect_id<<std::endl;
  REQUIRE( itia::rutils::getParamMatrix( node_handle, "/calib/"+kinect_id+"/R_kp", R_kp), "/calibration/R_kp" );
  
  std::vector< double > T_p_k;
  REQUIRE( node_handle.getParam("/calib/"+kinect_id+"/T_p_k", T_p_k), "T_p_k" );
  
  boost::array<double,3> bottom_left_vertex;
  REQUIRE( itia::rutils::getParamArray(node_handle, "/calib/"+kinect_id+"/bottom_left_vertex", bottom_left_vertex), "bottom_left_vertex" );
  
  boost::array<double,3> top_right_vertex;
  REQUIRE( itia::rutils::getParamArray(node_handle, "/calib/"+kinect_id+"/top_right_vertex", top_right_vertex), "top_right_vertex" );
     
  double bb_radius_cir;
  REQUIRE( node_handle.getParam("/swept/radius_cir", bb_radius_cir), "swept radius" );
  
  double bb_radius_seg;
  REQUIRE( node_handle.getParam("/swept/radius_seg", bb_radius_seg), "swept radius" );
  
  double bb_offset;
  REQUIRE( node_handle.getParam("/swept/offset", bb_offset), "swept offset" );

  std::string extraction_type;
  REQUIRE( node_handle.getParam("/swept/type", extraction_type), "extraction type" );
  
  std::string world_ref_sys; 
  if( source != "file" )   
    REQUIRE( node_handle.getParam("/" + source + "/world", world_ref_sys), "world reference system" );

  
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
  ROS_INFO("Create the source acquisition object");
  
  const int queue_size = 1000;
  DataSource* data_source = NULL;

  if( source == "file")          
  {
    data_source = new FileSource(queue_size, labels_used, R_kp, T_p_k, sourceid );
    ( (FileSource*)data_source )->boundaries( &bottom_left_vertex, &top_right_vertex ); //fix the boundaries, since they are already known
  }
  else if( source == "openni_tracker")  
  {
    data_source = new OpenNITracker(queue_size, labels_used, R_kp, T_p_k, world_ref_sys, outfiledir  );   //ref_sys - parte di codice che da warnings
  }
  else if( source == "k2_client")
  {
    data_source = new OpenNITracker(queue_size,labels_used, R_kp, T_p_k, world_ref_sys, outfiledir  );    //ref_sys
    std::cout<<"data source filled"<<std::endl;
    // std::cout<<"labels are:"<<data_source-><<std::endl;
  }
  else
  {
    ROS_ERROR("invalid selection");
    return -1;
  }

  //assert( data_source != NULL );
  
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ROS_INFO("Create the occupancy object(creation management of the on-line swept volume) ");
  double ds; 
  REQUIRE( node_handle.getParam("/occupancy_grid/ds", ds ), "/occupancy_grid/ds" );
  int    nrays;
  REQUIRE( node_handle.getParam("/occupancy_grid/nrays", nrays ), "/occupancy_grid/nrays" );
  
  OccupancyGrid og ( ds, bottom_left_vertex, top_right_vertex, nrays );
  
  ROS_INFO("Start the acquisition thread");
  data_source->start();

  //-----------------------------------------------------------
  ros::Time start_time = ros::Time::now();
  ROS_INFO("Start the occupancy swept volume creation");
  int cnt = 0;
  int total_frames = 0;
  int cycles = 0;
  int not_acceptable_frames = 0;
  stop = true;
  size_t cntIdle = 0;
  while( stop )
  {
    std::map<std::string, itia_occupancy_volume::xyz_t > new_data;

    if( data_source->pop(&new_data) ) 
    {      
      ros::Time st = ros::Time::now();
      for( auto it = circles.begin(); it != circles.end(); it++)
      {
        if(  new_data.find(it->at(0)) == new_data.end()  || new_data.find(it->at(1) ) == new_data.end()   )
        {
          std::cout  << "Line (circle) from " << it->at(0) << " to " << it->at(1) << " not available" << std::endl;
          continue;
        }
        
        if( !og.updateGridFromLine ( new_data[ it->at(0) ], new_data[ it->at(1) ], bb_radius_cir ) )
        {
          std::cout << "Line (circle) Element out  of range "
                    << " A: "<< itia_occupancy_volume::to_string( new_data[ it->at(0) ] ) <<", "
                    << " B: "<< itia_occupancy_volume::to_string( new_data[ it->at(0) ] ) << std::endl;
        }
      }
      for( auto it = segments.begin(); it != segments.end(); it++)
      {
        if(  new_data.find(it->at(0)) == new_data.end()  || new_data.find(it->at(1) ) == new_data.end()   )
        {
          std::cout  << "Line (segment) from " << it->at(0) << " to " << it->at(1) << " not available" << std::endl;
          continue;
        }
        if(!og.updateGridFromLine ( new_data[ it->at(0) ], new_data[ it->at(1) ], bb_radius_seg ) )
        {
          std::cout  << "Line (Segment) Element out  of range "
                    << " A: "<< itia_occupancy_volume::to_string( new_data[ it->at(0) ] ) <<", "
                    << " B: "<< itia_occupancy_volume::to_string( new_data[ it->at(1) ] ) <<"] "<< std::endl;

        }
      }
      for( auto it = trapezoids.begin(); it != trapezoids.end(); it++)
      {
        if(  new_data.find(it->at(0)) == new_data.end()  || new_data.find(it->at(1) ) == new_data.end()   )
        {
          std::cout  << "trapezoid " << it->at(0) << ", " << it->at(1) << it->at(2) << ", " << it->at(3) << " not available" << std::endl;
          continue;
        }
        itia_occupancy_volume::grid_error_t err;
        if(!og.updateGridFromTrapezoid( new_data[ it->at(0) ], new_data[ it->at(1) ], new_data[ it->at(2) ], new_data[ it->at(3) ], bb_offset, &err ))
        {
          std::cout << "Trapezoid Element out of range (err: "  << itia_occupancy_volume::to_string(err) <<") "
                    << " A: "<< itia_occupancy_volume::to_string( new_data[ it->at(0) ] ) <<", "
                    << " B: "<< itia_occupancy_volume::to_string( new_data[ it->at(1) ] ) <<", " 
                    << " C: "<< itia_occupancy_volume::to_string( new_data[ it->at(2) ] ) <<", "
                    << " D: "<< itia_occupancy_volume::to_string( new_data[ it->at(3) ] ) <<"] "<< std::endl;
        }
      }
      og.update();
      
      ros::Time nd = ros::Time::now();
      //std::cout << "DT: " << (nd - st).toSec() << std::endl;
      total_frames++;
    }
    else
    {
      if( (cntIdle++ % 100) == 0 )
      {
        std::cout << "Waiting for a new elements ... "<< std::endl;
      }
/*
      if( source == "file" )
      {
        std::cout << "Exit Cycle."<< std::endl;
        break;
      }
      if(source == "k2_client" && recording_data)
      {
        std::cout << "Exit Acquisition Cycle after "<< cycles << "cycles" <<  std::endl;
        break;
      }
*/
      std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }
    ros::spinOnce();
    
  }
  
  ros::Time end_time = ros::Time::now();
  std::cout << "==> mean processing time [s] " << (end_time-start_time).toSec() / cnt << " n cycles: " << cnt << std::endl; ;  
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////     
//
// Create the occupancy grid
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////     
  data_source->stop();
  ROS_INFO("Start the grid creation");

  clock_t begin = clock();
  og.terminate( );
  clock_t end = clock();
  double terminate_t = double(end - begin) / CLOCKS_PER_SEC;

  std::cout << "==> volume sorting [t] " << terminate_t << std::endl;
  std::cout << "==> grid n points:     " << og.getGridDimension() << std::endl;
  std::cout << "==> max occupancy:     " << og.getMaxOccupancy() << std::endl;
  std::cout << "==> min occupancy:     " << og.getMinOccupancy() << std::endl;    

  
  ROS_INFO("Start the saving of the yaml file");
  
  // Save YAML
  std::ofstream fd( outfiledir + "/points.yaml" );
  std::ofstream fdmat( outfiledir + "/points.mat" );
  
  fd << "occupancy_grid:" << std::endl;
  fd << "  ds: " << ds << std::endl;
  fd << "  bottom_left_vertex: [" << bottom_left_vertex[0] <<", "<<bottom_left_vertex[1]<<", "<<bottom_left_vertex[2]<<"]" << std::endl;
  fd << "  top_right_vertex: [" << top_right_vertex[0] <<", "<<top_right_vertex[1]<<", "<<top_right_vertex[2]<<"]" << std::endl;
  fd << "  nrays: " << nrays << std::endl;
  fd << "  points:" << std::endl;
  for(auto it = og.getGrid()->points.begin(); it != og.getGrid()->points.end(); it++)
  {
    if (it->hval != 0.0)
    {
      fd << "    - ["<< it->idx<<", " << it->xyz[0]<< ", " << it->xyz[1] << ", " << it->xyz[2] <<", "<< it->hval << "] "<< std::endl;
      fdmat          << it->idx<<", " << it->xyz[0]<< ", " << it->xyz[1] << ", " << it->xyz[2] <<", "<< it->hval        << std::endl;
    }
      
  }
  fd << "  samples:" << std::endl;
  const std::vector< int >& samples = og.getTrackedPoints();
  for(auto it = samples.begin(); it != samples.end(); it++)
  {
    fd << "    - "<< *it << std::endl;
  }
  fd << "  number_of_frames: "  << og.getFramesNumber()<< std::endl;
  fd << "  mean_samples: "      << og.getMeanTrackedPoints()<< std::endl;
  fd << "  min_samples: "       << og.getMinTrackedPoints()<< std::endl;
  fd << "  max_samples: "       << og.getMaxTrackedPoints()<< std::endl;
  fd << "  acquisition_time: "  << og.getAcquisitionTime()<< std::endl;
  fd.close();
  fdmat.close();

  ROS_INFO("Start the occupancy swept surfaces creation");
  std::vector< double > range_perc = { 0, 0.20, 0.40, 0.60, 0.80, 1.000 };
  for ( size_t iPerc = 0; iPerc < range_perc.size()-1; iPerc++ )
  {
    ROS_INFO("Surface between %f and %f [ perc ]", range_perc[ iPerc] *100.0, range_perc[iPerc+1] *100.0 );
    
    std::vector< xyz_t > points;
    begin = clock();
    og.extractSubset( range_perc[iPerc] * double( og.getMaxOccupancy() ), double( og.getMaxOccupancy() ), &points, extraction_type );
    end = clock();
    
    double extract_t = double(end - begin) / CLOCKS_PER_SEC;

    std::cout << "==> time to extract: " << extract_t << std::endl;
    
    std::string fn = "surf" + std::to_string(range_perc[iPerc]);
    
//     // Save YAML
//     std::ofstream fd( outfiledir + "/" + fn + ".yaml" );
//     fd << "vertexes:" << std::endl;
//     for(std::vector< std::vector<double> >::iterator jt=points.begin();  jt !=  points.end(); jt++ )
//     {
//       fd << "  - [" << jt->at(0)<< ", " << jt->at(1) << ", " << jt->at(2) <<"]"<< std::endl;
//     }
//     fd.close();
    
    // Save STL (both textual and binary)
    if( generateSTL( points, outfiledir, range_perc[ iPerc ], ds ) < 0 )
    {
      std::cout << "Error in generation STL. Exit. " << std::endl;
      return -1;
    }
  }

}
